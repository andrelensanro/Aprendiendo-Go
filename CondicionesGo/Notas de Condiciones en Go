1. El switch a diferencia de otros lenguajes como C y C++ no es necesario ponerle un break
2. Se puede colocar dos instrucciones en una misma linea siempre y cuando le pongas un punto 
y coma después de las instrucciones.
3. No está permitido no poner llaves en los if else o cualquier otra instrucción de bloque 
que solo contenga una sola instrucción.
------------

CR carry return
LF 

Linux(1 byte) \n new line 
Windows(2 byte) \n new line \r return 

------------

1. Instrucciones para imprimir por pantalla

a. fmt.Println("Hola", "mundo")
b. fmt.Printf("%d")
a. No es necesario poner un espacio, se introduce solo
b. Imprimir algo con formato

2. Instrucciones para recibir informacion

fmt.Scanf("%verbo", &nombreVar)
fmt.Scanln(&nombreVar)



3. Manejo de Strings

    Con Scanln NO se pueden introducir textos con espacios
para eso se usa el tipo de dato scanner

    Para concatenar dos strings se puede usar el operador
de suma, BUT NO sirve con los numeros


4. Manejo de errores

    Con la condicion del if sobre la funcion Scan de la variable
scanner se verifica que no haya ocurrido un error(Recordar 
que es un lenguaje que usa del lado del servidor)

5. Secciones
Se hace uso de rutinas en combinacion con un goto
Por ejemplo:
    RUTINA:
        goto RUTINA 
Lo anterior sería un ciclo infinito, hay que tratarlo con condicionales, de tal
forma que se comporte como un continue con una ligera modificación.

6. Funciones
Con go se puede devolver más de un valor en una función
Con go se puede crear más de una variable y asignarle al mismo tiempo un valor
Por ejemplo:
    numero, estado := dos(5)
A mi parecer ya no hay que indicarle que se recibirá un int y un bool ya que 
se crea en función de los tipos de datos que retorna la función
Con go se puede nombrar la variable de retorno y simplemenete colocar las
operaciones con esa variable, al final es necesario colocar la palabra return
Por ejemplo:
    func funcionUno(entero int) (z int){
        z = entero*2
        return
    }

Funciones Variádicas

Importante:
Con go NO se puede hacer uso de sobrecargar funciones como en otros lenguajes de programación. En golang existe un concepto un tanto
similar respecto a la variación de parametros que son las funciones
variádicas, donde si no se sabe cuántos parametros exactamente pueden
venir de una función o la cantidad de parametros puede variar se hace 
uso de éstas de la siguiente forma:

func funcionVariadica(parametro ...int) int{

}
los tres puntos está indicando que va a recibir un arreglo de enteros

range sobre un vector o arreglo de go, devuelve dos valores:
    1ro. el numero de elemento dentro del arreglo (iterador)
    2do. el valor del elemento dentro del arreglo

el uso de _ (guion bajo) ignora valores retornados 

for it, num := range parametro{
    fmt.Println(it, num)
}

Recuerda: funciones publicas con mayuscula el nombre, funciones locales 
con minuscula el nombre.


7. Funciones anonimas
Con go se puede crear funciones que se pueden modificar en tiempo de ejecución

Por ejemplo: 
    var Calculo func(int, int) int = func(num1 int, num2 int) int{

    }
La variable Calculo es de tipo funcion que recibe dos enteros y retorna un entero. 

Lo bueno de esto, es semejante a sobrecargar la funciones, solo que el numero y tipo de parametros debe ser respetado (ahí la sutileza diferencia).
    Calculo = func(num1 int, num2 int) int{

    }

8. Closures
Características:
    Protección e insolación de código
    Pueden acceder a variables creadas fuera de la función
    Función que devuelve una función.

Por ejemplo:
    func Tabla(valor int) func() int{
        numero:=valor 
        secuencia:=0
        return func() int{
            secuencia+=1  
            return numero*secuencia
        }
    }


	tablaDel2:=2
	Mitabla:=Tabla(tablaDel2)

    func Mitabla() {
		secuencia+=1  
		return numero*secuencia
	}


9. Arreglos 

Los arreglos en go pasan a ser muy similares a C y lo podemos imprimir como lo hace python

Por ejemplo: se puede declarar un arreglo (1 dimensión) de tres formas distintas

    var vector [10]int
    vector := [10]int 
    vector := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}

Una matriz de manera semejante solo que con dos o n pares de corchetes

10. Los slices tipo python

Son referencias a segmentos de arreglos, por lo que si son modificados se modificaran también los arreglos de donde provienen.

10.1 Slice formado con make

Por ejemplo: 

    elementos := make([]int, 10, 20)
    elementos := make([]int, 0, 0) <- también funciona a mi parecer es más costoso hacer algo así

Existen dos conceptos distintos en un slice con make: largo (2do parametro) y capacidad (3er parametro):

largo: es el tamaño que se m
capacidad: es el tamaño maximo al cuál podría crecer

Las asignaciones simples se hacen mientras todavía el largo sea válido.
Después se hace con append hasta que se acabe la capacidad o más.

El append es una operación costosa cuando la memoria que se aparto en un inicio 
no es suficiente y tiene que buscar un nuevo lugar en la memoria para continuar 
almacenando.

La asignación se hace de la siguiente manera: elementos[i] = -1
Mientras que con el append se hace así: elementos = append(elementos, -1)

11. Mapas

Los mapas se pueden crear de varias maneras.
Primera. con la función make:

    paises := make(map[string]string)
    paises := make(map[string]string, 5)
    campeonato := map[string]int{
        "Algo":23,
        "Siguiente valor": 23}
    
En el segundo se está indicando un valor refiriendo el tamaño del mapa, pero si se requiere agrandar go lo hará.
Colocar el ultimo corchete al final de la última línea.
Ordena de forma ascendente en función de la clave o key.

Operaciones sobre un map:
Agregar y modificar (igualito al map de c++) : 
    campeonato["River Plate"] = 25

Eliminar
    delete(campeonato, "Real madrid")
Recorrer 










